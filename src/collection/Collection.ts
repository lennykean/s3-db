import { getMetadata } from '../utils/Metadata';
import { S3Client, S3Metadata } from '../s3';
import { S3DB } from '../db';
import { CollectionConfiguration } from './';
import { SaveBehavior } from './behaviors/SaveBehavior';
import { HeadBehavior } from './behaviors/HeadBehavior';
import { ExistsBehavior } from './behaviors/ExistsBehavior';
import { LoadBehavior } from './behaviors/LoadBehavior';
import { DeleteBehavior } from './behaviors/DeleteBehavior';
import { FindBehavior } from './behaviors/FindBehavior';
import { ReferenceList } from './ReferenceList';

/**
 * Provides the logical interfaces of a collection and translates it into the
 * appropriate S3 calls.
 *
 * Usage: const myCollection: Collection<SomeType> = new Collection(SomeType);
 *
 * The 'SomeType' definition needs to have [prop: string]: any; on it to avoid
 * a TypeScript collission issue when it interprets the 'two types'.
 */
export class Collection<Of extends any> {
  private type: Of;
  private name: string;
  private idPrefix?: string;
  private fullBucketName: string;
  private configuration: CollectionConfiguration;
  private s3Client: S3Client;

  private saveBheavior: SaveBehavior<Of>;
  private existsBehavior: ExistsBehavior<Of>;
  private loadBehavior: LoadBehavior<Of>;
  private deleteBehavior: DeleteBehavior<Of>;
  private findBehavior: FindBehavior<Of>;
  private headBehavior: HeadBehavior<Of>;

  constructor(type: Of, idPrefix?: string) {
    let metadata: any = getMetadata(type);

    this.type = type;
    this.name = metadata.name || `${type}`;
    this.idPrefix = idPrefix;
    this.configuration = metadata;
    this.fullBucketName = S3DB.getCollectionFQN(name);
    this.s3Client = new S3Client(this.configuration);

    this.headBehavior = new HeadBehavior(
      type,
      this.configuration,
      this.s3Client,
      this.fullBucketName,
      this.name,
      this.idPrefix
    );
    this.existsBehavior = new ExistsBehavior(
      type,
      this.configuration,
      this.s3Client,
      this.fullBucketName,
      this.name,
      this.idPrefix
    );
    this.loadBehavior = new LoadBehavior(
      type,
      this.configuration,
      this.s3Client,
      this.fullBucketName,
      this.name,
      this.idPrefix
    );
    this.saveBheavior = new SaveBehavior(
      type,
      this.configuration,
      this.s3Client,
      this.fullBucketName,
      this.name,
      this.idPrefix
    );
    this.deleteBehavior = new DeleteBehavior(
      type,
      this.configuration,
      this.s3Client,
      this.fullBucketName,
      this.name,
      this.idPrefix
    );
    this.findBehavior = new FindBehavior(
      type,
      this.configuration,
      this.s3Client,
      this.fullBucketName,
      this.name,
      this.idPrefix
    );
  }

  /**
   * The prefix provided will sit in front of all operations for this collection. This means
   * that any ID lookup will add the prefix when looking up the object. So if the prefix is
   * `/users/` then when `.load('1234')` is called the request will result in an ID lookup for
   * `/users/1234`. Similarly, all objects saved will have the prefix applied when the ID is
   * generated by the save operation, or, when an ID is provided and it does not `startWith()`
   * the configured prefix.
   *
   * @param prefix to place all documents within this collection.
   */
  public subCollection(prefix: string): Collection<Of> {
    return new Collection<Of>(this.type, `${this.idPrefix}${prefix}`);
  }

  public async head(id: string): Promise<S3Metadata> {
    return this.headBehavior.head(id);
  }

  public async exists(id: string): Promise<boolean> {
    return this.existsBehavior.exists(id);
  }

  public async load(id: string): Promise<Of> {
    return this.loadBehavior.load(id);
  }

  public async save(toSave: Of): Promise<Of> {
    return this.saveBheavior.save(toSave);
  }

  public async delete(id: string): Promise<boolean> {
    return this.deleteBehavior.delete(id);
  }

  public async find(prefix: string, pageSize?: number, continuationToken?: string): Promise<ReferenceList> {
    return this.findBehavior.find(prefix, pageSize, continuationToken);
  }
}
